#!/bin/sh

#
# a cron script that replicates zfs datasets to a remote machine
#

PATH=/bin:/usr/bin:/sbin

version="0.1"

base_snap="shadow.base"
delta_snap="shadow.delta"
ec=0

unset zfshadow_tags zfshadow_tag zfshadow_tag_cfg

send_dataset()
{
    local local=$(echo "$1" | sed 's/:.*//')
    local remote=$(echo "$1" | sed 's/.*://')

    zfs list -H "$local" >/dev/null 2>&1

    if [ $? != 0 ]
    then
        err "could not find dataset $local"
        return
    fi

    # get a list of all the datasets under the specified dataset
    local datasets=$(zfs list -H -r -o name $local)

    # iterate through each dataset and send a backup
    for dataset in $datasets
    do
        log "  started processing $dataset at $(date)"

        local ignore=$(zfs get -H -o value zfshadow:ignore $dataset)

        if [ "$ignore" == "yes" ]
        then
            log "  skipping $dataset (zfshadow:ignore property set)"
            continue
        fi

        # calculate what the remote dataset's name is
        local remote_dataset="$remote$(echo $dataset | sed 's|^[^/]*||')"

        # blindly try to create the base snapshot, then check the
        # return code to branch on either sending the initial data, or sending
        # an incremental stream.
        zfs snapshot $dataset@$base_snap >/dev/null 2>&1

        if [ $? == 0 ]
        then
            # the base snapshot was just created, destroy any remote data
            # and start fresh
            log "    initial snapshot $dataset@$base_snap created, clearing remote host's copy (if any)"

            ssh $host -p $port zfs destroy -r "$remote_dataset" > /dev/null 2>&1
            zfs destroy $dataset@$delta_snap > /dev/null 2>&1 

            # if the local dataset is the root dataset of the pool, then the
            # above will have destroyed the target, so re-create it.
            if [ "$remote_dataset" == "$remote" ]
            then
                ssh $host -p $port zfs create "$remote_dataset" > /dev/null 2>&1
            fi

            log "    sending $dataset@$base_snap to $host"

            local send_output=$(zfs send $dataset@$base_snap | gzip | ssh $host -p $port "gzcat | zfs recv -duv $remote" 2>&1)

            if [ $? == 0 ]
            then
                log "    successfully sent snapshot '$dataset@$base_snap'"
            else
                err "    failed to send snapshot '$dataset@$base_snap', destroying newly created base snapshot - output: $send_output"

                # destroy the newly created base snapshot so that the next time
                # this script is run, the base snapshot will be re-created and
                # re-sent
                zfs destroy $dataset@$base_snap > /dev/null 2>&1
            fi
        else
            # first check to see if there already is an existing delta snapshot. If
            # there is, then this means we were unable to clean up the remote host's snapshots
            # and should do so now. Otherwise, create the delta snapshot and send.

            # try up to 6 times to clean up any existing delta snapshots
            for attempt in 1 2 3 4 5 6
            do
                zfs list -H -o name $dataset@$delta_snap >/dev/null 2>&1

                if [ $? != 0 ]
                then
                    # there aren't any delta snapshots on this machine, so break out of the loop
                    break
                else
                    log "    delta snapshot $dataset@$delta_snap still exists, updating remote snapshots (attempt #$attempt)"

                    update_snapshots $dataset $remote_dataset

                    # on the off chance that we failed to update the snapshots again,
                    # sleep 10 seconds so that each attempt is made 10 seconds apart
                    sleep 10
                fi
            done

            local snapshot_output=$(zfs snapshot $dataset@$delta_snap 2>&1)

            if [ $? != 0 ]
            then
                # despite trying to clean up any left over snapshots, we still
                # failed to create a snapshot. go ahead and abort for now, with the
                # hope that a later invocation of this script will have success
                err "  failed to create the delta snapshot '$dataset@$delta_snap' - output: $snapshot_output"

                # move on to the next dataset
                continue
            fi

            log "    sending $dataset@$delta_snap to $host"

            local send_output=$(zfs send -i $base_snap $dataset@$delta_snap | gzip | ssh $host -p $port "gzcat | zfs recv -duv $remote" 2>&1)

            if [ $? == 0 ]
            then
                log "    successfully sent $dataset@$delta_snap, updating base snapshot"

                update_snapshots $dataset $remote_dataset
            else
                err "    failed to send $dataset@$delta_snap, destroying newly created delta snapshot - output: $send_output"

                # since we couldn't send it, just destroy it. If this
                # script gets invoked again the delta snapshot will just be recreated.
                zfs destroy $dataset@$delta_snap
            fi
        fi

        log "  finished processing $dataset at $(date)"
    done
}

update_snapshots()
{
    # process remote snapshots
    log "      destroying remote snapshot $2@$base_snap"
    ssh $host -p $port zfs destroy $2@$base_snap >/dev/null 2>&1

    log "      renaming remote snapshot $2@$delta_snap to $2@$base_snap"
    local rename_output=$(ssh $host -p $port zfs rename $2@$delta_snap $2@$base_snap 2>&1)

    if [ $? == 0 ]
    then
        # process local snapshots
        log "      destroying local snapshot $1@$base_snap"
        zfs destroy $1@$base_snap >/dev/null 2>&1

        log "      renaming local snapshot $1@$delta_snap to $1@$base_snap"
        zfs rename $1@$delta_snap $1@$base_snap >/dev/null 2>&1
    else
        err "      failed to rename the remote snapshot $2@$delta_snap to $2@$base_snap - output: $rename_output"
    fi
}

send_tag()
{
    local tag="$1"
    local dataset

    load_tag "$tag"

    [ $? == 0 ] || exerr "invalid tag configuration for '$tag'"

    local datasets=$(get_datasets_for_tag "$tag")

    for dataset in $datasets
    do
        echo "sending $dataset using scheme $zfshadow_tag_scheme"
    done
}

load_tags()
{
    if [ -z "$zfshadow_tags" ]
    then
        zfshadow_tags=$(zfs get -H -s local -t filesystem -o property all | grep '^zfshadow:[a-zA-Z0-9_]*\.cfg$' | sed -e 's/^zfshadow:\([a-zA-Z0-9_]*\)\.cfg$/\1/' | sort | uniq | tr '\n' ' ')
    fi
}

load_tag()
{
    if [ "$zfshadow_tag" != "$1" ]
    then
        zfshadow_tag="$1"
        zfshadow_tag_cfg=$(zfs get -H -s local -o value zfshadow:$1.cfg | head -n 1)

        parse_tag_cfg "$zfshadow_tag_cfg"
    fi
}

check_tag()
{
    local check_tag="$1"
    local tag

    load_tags

    for tag in $zfshadow_tags
    do
        if [ $check_tag == $tag ]
        then
            return 0
        fi
    done

    return 1
}

get_cfg_option()
{
    echo "$1" | grep -o "|$2=[^|]*|" | sed -e "s/|$2=\([^|]*\)|/\1/"
}

parse_tag_cfg()
{
    unset zfshadow_tag_scheme zfshadow_tag_target zfshadow_ssh_args zfshadow_ssh_gzip

    zfshadow_tag_scheme=$(echo "$1" | sed -e 's/\([^|]*\)|.*/\1/')
    zfshadow_tag_target=$(echo "$1" | sed -e "s/$zfshadow_tag_scheme|\([^|]*\)|.*/\1/")

    case $zfshadow_tag_scheme in
        local)
            ;;
        ssh)
            local host=$(get_cfg_option "$1" host)
            local port=$(get_cfg_option "$1" port)
            local user=$(get_cfg_option "$1" user)
            local gzip=$(get_cfg_option "$1" gzip)

            [ ! -z "$host" ] || return 1

            zfshadow_ssh_args="$host"

            [ -z "$user" ] || zfshadow_ssh_args=$(echo "$user@$zfshadow_ssh_args")

            [ -z "$port" ] || zfshadow_ssh_args=$(echo "$zfshadow_ssh_args -p $port")

            [ "$gzip" == "yes" ] && zfshadow_ssh_gzip="yes"
            ;;
        *)
            return 1
    esac

    return 0
}

get_datasets_for_tag()
{
    local tag="$1"

    zfs get -H -t filesystem -o name,value zfshadow:$tag | grep '[[:space:]]send' | awk '{ print $1 }'
}

parse_tags()
{
    load_tags

    local tags=""

    if [ $# == 0 ]
    then
        tags=$zfshadow_tags
    else
        while [ $# -gt 0 ]
        do
            check_tag "$1" || exerr "tag $1 does not exist"

            if [ -z "$tags" ]
            then
                tags="$1"
            else
                tags=$(echo "$tags $1")
            fi

            shift
        done
    fi

    echo $tags
}

log()
{
    echo "$1"
    logger -t zfshadow "$1"
}

err()
{
    ec=1
    log "_FAILURE_: $1"
}

exerr()
{
    echo -e "$*" >&2
    exit 1
}

usage()
{
    echo "usage: zfshadow [-p port] [-h] dest_host local_dataset1:remote_dataset1 [local_dataset2:remote_dataset2] ..."
    echo " -p port: the ssh port to connect to on the remote host"
    echo " -h: print this help"
    echo " -v: print the version info"
    echo " dest_host: the destination host to receive the datasets from"
    echo " local_dataset1: the local dataset to replicate"
    echo " remote_dataset1: the place to replicate local_dataset1 to"
}

version()
{
    echo "zfshadow version $version"
}

########## END FUNCTION DECLARATIONS ##########

case "$1" in
#
# create - create a tag and its properties
# update - change a tag and its properties
#
create|update)
    action="$1"
    shift

    if [ $# -lt 3 ]
    then
        usage
        exit 1
    fi

    echo "$1" | grep -qv "[^a-zA-Z0-9_]" || \
        exerr "tag names can only contain a-z, 0-9, and _ characters"

    tag="$1"
    options=""

    if [ "$action" == "create" ]
    then
        check_tag "$tag"

        [ $? != 0 ] || exerr "tag '$tag' already exists, did you mean 'update'?"
    fi

    shift; while getopts :s:t:o: arg; do case ${arg} in 
      s) tag_scheme=${OPTARG};;
      t) tag_target=${OPTARG};; 
      o)
          echo ${OPTARG} | grep -Eq '^[a-zA-Z]+=[^|]+$'
          [ $? == 0 ] || exerr "a tag option must be of the form name=value, where value does not contain the '|' character"

          options=$(echo "$options${OPTARG}|")
          ;;
      ?) usage;; 
    esac; done; shift $(( ${OPTIND} - 1 ))

    [ ! -z "$tag_scheme" ] || \
        exerr "the scheme is requried (-s <scheme>)"

    [ ! -z "$tag_target" ] || \
        exerr "the target dataset is required (-t <target>)"

    tag_cfg="$tag_scheme|$tag_target|$options"

    parse_tag_cfg "$tag_cfg"

    [ $? == 0 ] || exerr "invalid options list for $tag_scheme"

    # when creating a new tag, add the tag properties to every pool
    # so it's a global property regardless of what pools are connected
    all_pools=$(zpool list -H -o name)

    echo "creating $tag"
    zfs set zfshadow:$tag.cfg=$tag_cfg $all_pools > /dev/null 2>&1

    [ $? == 0 ] || exerr "failed to create tag $tag"

    ;;

#
# tag - tag a dataset for sending
#
tag)
    shift

    [ $# == 2 ] || exerr "usage: zfshadow tag <dataset> <tag>"

    check_tag "$2"

    [ $? == 0 ] || exerr "tag '$2' not found"

    zfs list -H -o name "$1" > /dev/null 2>&1

    [ $? == 0 ] || exerr "dataset '$1' not found"

    zfs set "zfshadow:$2=send" "$1" > /dev/null 2>&1

    [ $? == 0 ] || exerr "failed to tag dataset '$1' with '$2'"

    ;;

#
# list - list all tags
#
list)
    shift

    list_tags=$(parse_tags $@)

    [ $? == 0 ] || exit 1

    printf "TAG\t\tDATASET\n"

    for tag in $list_tags
    do
        datasets=$(get_datasets_for_tag $tag)

        for dataset in $datasets
        do
            printf "%s\t\t%s\n" $tag $dataset
        done
    done
    ;;
#
# send - send datasets somewhere
#
send)
    shift

    send_tags=$(parse_tags $@)

    [ $? == 0 ] || exit 1

    log "started processing datasets at $(date)"

    for tag in $send_tags
    do
        send_tag $tag
    done

    log "finished processing datasets at $(date)"
    ;;

#
# error - unrecognized command
#
*)
    usage
    ;;
esac


exit $ec
